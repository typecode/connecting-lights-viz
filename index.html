<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Prototyping</title>
		<link rel="stylesheet" href="static/css/reset.css">
		<link rel="stylesheet" href="static/css/booklr.css">
		<link rel="stylesheet" href="static/css/connected_lights.css">

		<!-- Type/Code Libraries -->
		<script type='text/javascript' src='static/js/lib/typecode-js/lib/tc.seed.js'></script>

		<!-- Application Page -->
		<script type='text/javascript'>
			window.console = NI.app.getConsole(true);
			window.page = {
				modules: {},
				features: []
			};
			window.onunload = function(){}; // fixes back-button problems in safari and ff
		</script>


	</head>

	<body>
		<div id='application' class="app-wrap">
			<p id='animation-frame-id'></p>
		</div>

		<!-- jQuery & Other Libraries -->
		<script src='static/js/lib/jquery-1.7.2.min.js'></script>

		<!-- d3.js -->
		<script src='static/js/lib/d3/d3.v2.js'></script>

		<!-- three.js -->
		<script src='static/js/lib/three.js/build/Three.js'></script>

		<!-- threex 
		<script src='static/js/lib/threex/threex.domevent.js'></script>
		<script src='static/js/lib/threex/threex.domevent.object3d.js'></script> -->

		<!-- d3-threeD -->
		<script src='static/js/lib/d3-threeD/lib/d3-threeD.js'></script>

		<!-- leaflet -->
		<script src='static/js/lib/leaflet/dist/leaflet.js'></script>
		<link rel="stylesheet" href="static/js/lib/leaflet/dist/leaflet.css">

		<!-- stats.js -->
		<script src='static/js/lib/stats.js/build/Stats.js'></script>

		<!-- geo-util from http://www.smartjava.org/examples/threed3s/ -->
		<script src='static/js/lib/geo-util.js'></script>

		<!-- Type/Code Libraries -->
		<script src='static/js/lib/typecode-js/lib/tc.app.js'></script>
		<script src='static/js/lib/typecode-js/lib/tc.overlay.js'></script>

		<!-- Site-wide Application Modules -->

		<!-- Application -->
		<script type='text/javascript'>

		</script>
		
		<!-- Application -->
		<script type='text/javascript'>

			var Viz_Two = function(options) {
					
				var o, internal, elements, fn, handlers;
				
				o = $.extend({
					app:null,
					$e:null,
					selector:'',
					width: 600,
					height: 600
				}, options);
				
				internal = {
					name:'Module.Viz_Two',
					$e:(o.$e ? o.$e : $(o.selector)),

					
				};

				elements = {
					window: $(window),
					map: null
				};

				fn = {
					init: function(){
						internal.stats = new Stats();
						internal.stats.setMode(0); // 0: fps, 1: ms
						internal.stats.domElement.style.position = 'absolute';
						internal.stats.domElement.style.right = '0px';
						internal.stats.domElement.style.top = '0px';
						document.body.appendChild( internal.stats.domElement );


						internal.$e.css({
							'height': o.height + 'px',
							'width': o.width + 'px'
						});

						internal.map = L.map('application').setView([51.505, -0.09], 13);

						L.tileLayer('http://{s}.tile.cloudmade.com/fbcae4e80bd94f61ad844c9a52158e08/997/256/{z}/{x}/{y}.png', {
							 attribution: 'some attribution',
							maxZoom: 18
						}).addTo(internal.map);

						internal.canvasTiles = L.tileLayer.canvas({
							options: {
								debug: false
							},

							tileSize: 256,

							initialize: function (options) {
								L.Util.setOptions(this, options);

								this.drawTile = function (canvas, tilePoint, zoom) {
									var ctx = {
										canvas: canvas,
										tile: tilePoint,
										zoom: zoom
									};

									if (this.options.debug) {
										this._drawDebugInfo(ctx);
									}
									this._draw(ctx);
								};
							},

							_draw: function(ctx){
								console.log('_draw');
							}
						});



/*
						var nwPoint = ctx.tile.multiplyBy(this.tileSize);
		var sePoint = nwPoint.add(new L.Point(this.tileSize, this.tileSize));

		// optionally, enlarge request area.
		// with this I can draw points with coords outside this tile area,
		// but with part of the graphics actually inside this tile.
		// NOTE: that you should use this option only if you're actually drawing points!
		var buf = this.options.buffer;
		if (buf > 0) {
			var diff = new L.Point(buf, buf);
			nwPoint = nwPoint.subtract(diff);
			sePoint = sePoint.add(diff);
		}

		var nwCoord = this._map.unproject(nwPoint, ctx.zoom, true);
		var seCoord = this._map.unproject(sePoint, ctx.zoom, true);
		var bounds = [nwCoord.lng, seCoord.lat, seCoord.lng, nwCoord.lat];

						internal.canvasTiles.drawTile = function(canvas, tilePoint, zoom) {
							console.log(tilePoint);
							console.log(L.Projection.LonLat.unproject(tilePoint));


							var context = canvas.getContext('2d');
							// Circle
							context.beginPath();
							context.arc(10, 10, 5, 0, 2 * Math.PI, false);

							// Fill (Gradient)
							var grd = context.createRadialGradient(10, 10, 5, 10, 10, 5);
							grd.addColorStop(0, "#8ED6FF");
							grd.addColorStop(1, "#004CB3");
							context.fillStyle = grd;

							// Shadow
							context.shadowColor = "#666666";
							context.shadowBlur = 5;
							context.shadowOffsetX = 7;
							context.shadowOffsetY = 7;
							context.fill()

							context.lineWidth = 2;
							context.strokeStyle = "black";
							context.stroke();

							// Text
							context.lineWidth = 1;
							context.fillStyle = "#000000";
							context.lineStyle = "#000000";
							context.font = "12px sans-serif";
							context.textAlign = "center";
							context.textBaseline = "middle";
							//context.fillText(i + 1, x, y);
							//console.log('drawTile---' + tilePoint.x + ':' + tilePoint.y);
							// draw something on the tile canvas
						};



						internal.canvasTiles.addTo(internal.map);
						internal.canvasTiles.redraw();
*/						

						jQuery.getJSON('static/data/hadrians-wall.json', function(d){
							console.log(d);
							L.geoJson(d, {
								style: function (feature) {
									return {
										"color": "#ff7800",
										"weight": 5,
										"opacity": 0.65
									};
								},
								onEachFeature: function (feature, layer) {
									layer.bindPopup(feature.properties.description);
								}
							}).addTo(internal.map);
						});

						jQuery.getJSON('static/data/balloons/output.json', function(d){
							console.log(d);
							L.geoJson(d, {
								style: function (feature) {
									return {
										"color": "#ff7800",
										"weight": 5,
										"opacity": 0.65
									};
								},
								onEachFeature: function (feature, layer) {
									layer.bindPopup(feature.properties.description);
								}
							}).addTo(internal.map);
						});
						
					},

					animate: function(frame_time){
						var delta;
						delta = frame_time - internal.last_frame;
						internal.last_frame = frame_time;
						internal.stats.begin();
						internal.animation_frame_id = requestAnimationFrame( fn.animate );
						fn.draw(delta);
					},

					draw: function(){
						internal.canvasTiles.redraw();
						internal.stats.end();
					}
				};

				handlers = {
					keypress: function(e, d){
						if(e.which == 112){ // 'p'
							if(internal.animation_frame_id){
								cancelAnimationFrame(internal.animation_frame_id);
								internal.animation_frame_id = null;
							} else {
								internal.animation_frame_id = requestAnimationFrame(fn.animate);
							}
						}
					},
					resize: function(){
						
					}
				};

				jQuery(window).bind('keypress', {}, handlers.keypress);
				jQuery(window).bind('resize', {}, handlers.resize);

				o.app.events.bind('app.featuresInitialized', {}, function(){
					fn.init();
					fn.animate();
				});
				
				console.log(internal);

			};

			window.page.features.push(function(app){
				app.runtime.viz = new Viz_Two({
					app: app,
					$e: $('#application'),
					width: $(window).width(),
					height: $(window).height()
				});
			});
			
			jQuery(document).bind('ready',function(){
				window.app = new NI.App({
					page: window.page
				});
			});
		</script>

	</body>
</html>
