<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Prototyping</title>
		<link rel="stylesheet" href="static/css/reset.css">
		<link rel="stylesheet" href="static/css/booklr.css">
		<link rel="stylesheet" href="static/css/connected_lights.css">

		<!-- Type/Code Libraries -->
		<script type='text/javascript' src='static/js/lib/typecode-js/lib/tc.seed.js'></script>

		<!-- Application Page -->
		<script type='text/javascript'>
			window.console = NI.app.getConsole(true);
			window.page = {
				modules: {},
				features: []
			};
			window.onunload = function(){}; // fixes back-button problems in safari and ff
		</script>


	</head>

	<body>
		<div id='application' class="app-wrap"></div>

		<p id='n-particles'></p>

		<!-- jQuery & Other Libraries -->
		<script src='static/js/lib/jquery-1.7.2.min.js'></script>

		<!-- d3.js -->
		<script src='static/js/lib/d3/d3.v2.js'></script>

		<!-- three.js -->
		<script src='static/js/lib/three.js/build/Three.js'></script>

		<!-- threex 
		<script src='static/js/lib/threex/threex.domevent.js'></script>
		<script src='static/js/lib/threex/threex.domevent.object3d.js'></script> -->

		<!-- d3-threeD -->
		<script src='static/js/lib/d3-threeD/lib/d3-threeD.js'></script>

		<!-- leaflet -->
		<script src='static/js/lib/leaflet/dist/leaflet.js'></script>
		<link rel="stylesheet" href="static/js/lib/leaflet/dist/leaflet.css">

		<!-- leaflet: TileLayer.TileJSON.js -->
		<script src='static/js/lib/TileLayer.TileJSON.js'></script>

		<!-- stats.js -->
		<script src='static/js/lib/stats.js/build/Stats.js'></script>

		<!-- geo-util from http://www.smartjava.org/examples/threed3s/ -->
		<script src='static/js/lib/geo-util.js'></script>

		<!-- Type/Code Libraries -->
		<script src='static/js/lib/typecode-js/lib/tc.app.js'></script>
		<script src='static/js/lib/typecode-js/lib/tc.overlay.js'></script>

		<!-- Site-wide Application Modules -->

		<!-- Application -->
		<script type='text/javascript'>

		</script>
		
		<!-- Application -->
		<script type='text/javascript'>

			var Viz_Two = function(options) {
					
				var o, internal, elements, fn, handlers;
				
				o = $.extend({
					app:null,
					$e:null,
					selector:'',
					width: 600,
					height: 600,
					tileSize: 256,
					buffer: 5
				}, options);
				
				internal = {
					name:'Module.Viz_Two',
					$e:(o.$e ? o.$e : $(o.selector)),
					particles: []
				};

				elements = {
					window: $(window),
					map: null,
					n_particles: $('#n-particles')
				};

				fn = {
					init: function(){
						internal.stats = new Stats();
						internal.stats.setMode(0); // 0: fps, 1: ms
						internal.stats.domElement.style.position = 'absolute';
						internal.stats.domElement.style.right = '0px';
						internal.stats.domElement.style.top = '0px';
						document.body.appendChild( internal.stats.domElement );


						internal.$e.css({
							'height': o.height + 'px',
							'width': o.width + 'px'
						});

						internal.map = L.map('application');

						fn.generate_particles(10);

						L.tileLayer('static/map_tms_/1.0.0/ConnectingLights/{z}/{x}/{y}.png', {
							errorTileUrl: 'static/map_tms_/error_tile.png',
							minZoom:9,
							maxZoom: 15,
							tms:true
						}).addTo(internal.map);

						internal.map.setView([54.9839, -2.3291], 10);

						internal.canvasTiles = new L.TileLayer.Canvas({
							
						});

						internal.canvasTiles.tileSize = 256;

						internal.canvasTiles.drawTile = fn.drawTile;

						internal.canvasTiles.addTo(internal.map);

					},

					generate_particles: function(n_particles){
						var parameters, i;

						parameters = {
							bounds: new L.LatLngBounds(new L.LatLng(54.7516,-3.5898), new L.LatLng(55.1804,-1.0849))
						};

						for(i = 0; i < n_particles; i++){
							internal.particles.push({
								lat_lng: null,
								position_on_line: Math.random(0),
								velocity: (Math.random() * 0.01) - 0.005
							});
						}
					},

					update_particles: function(){
						var i, my_particle;
						for(i = 0; i < internal.particles.length; i++){
							my_particle = internal.particles[i];
							my_particle.position_on_line = my_particle.position_on_line + my_particle.velocity;
							if(my_particle.position_on_line < 0 || my_particle.position_on_line > 1){
								my_particle.velocity = my_particle.velocity * -1;
								if(my_particle.position_on_line < 0){
									my_particle.position_on_line = 0;
								}
								if(my_particle.position_on_line > 1){
									my_particle.position_on_line = 1;
								}
							}
							my_particle.lat_lng = fn.map_position_on_line_2_lat_lng(my_particle.position_on_line);
						}
					},

					drawTile: function(canvas, tilePoint, zoom){

						var ctx, bounds, particles_to_draw, i;

						ctx = {
							map: this._map,
							canvas: canvas,
							context: canvas.getContext('2d'),
							tile: tilePoint,
							zoom: zoom
						};

						bounds = fn.get_canvas_bounds(ctx, o.buffer);
						particles_to_draw = fn.get_particles_for_bounds(bounds);

						ctx.context.clearRect (0,0, ctx.canvas.width, ctx.canvas.height);
						for(i = 0; i < particles_to_draw.length; i++){
							fn.draw_particle(ctx, particles_to_draw[i])
						}

					},

					draw_particle: function(ctx, particle){

						var style, geom, p, c, g;

						style = {
							color: 'rgba(252,146,114,0.6)',
							radius: 5
						};

						geom = particle.lat_lng;

						p = this.get_tile_point(ctx, geom);
						c = ctx.canvas;
						g = ctx.context;
						g.beginPath();
						g.fillStyle = style.color;
						g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);
						g.closePath();
						g.fill();
						g.restore();
					},

					get_canvas_bounds: function(ctx, buf){
						//potentially a slow function - look at caching it on the canvas object?


						var nwPoint, sePoint, diff, nwCoord, seCoord, swLatLng, neLatLng, bounds;
					
						nwPoint = ctx.tile.multiplyBy(o.tileSize);
						sePoint = nwPoint.add(new L.Point(o.tileSize, o.tileSize));

						// optionally, enlarge request area.
						// with this I can draw points with coords outside this tile area,
						// but with part of the graphics actually inside this tile.
						// NOTE: that you should use this option only if you're actually drawing points!
						if (buf > 0) {
							diff = new L.Point(buf, buf);
							nwPoint = nwPoint.subtract(diff);
							sePoint = sePoint.add(diff);
						}

						nwCoord = ctx.map.unproject(nwPoint, ctx.zoom, true);
						seCoord = ctx.map.unproject(sePoint, ctx.zoom, true);

						swLatLng = new L.LatLng(seCoord.lat, nwCoord.lng);
						neLatLng = new L.LatLng(nwCoord.lat, seCoord.lng);
						bounds = new L.LatLngBounds(swLatLng, neLatLng);
						
						return bounds;
					},

					get_particles_for_bounds: function(bounds){
						var i, output;
						output = [];
						for(i = 0; i < internal.particles.length; i++){
							
							if(internal.particles[i].lat_lng && bounds.contains(internal.particles[i].lat_lng)){
								output.push(internal.particles[i]);
							}
						}
						return output;
					},

					get_tile_point: function(ctx, coords){
						// start coords to tile 'space'
						var s = ctx.tile.multiplyBy(o.tileSize);

						// actual coords to tile 'space'
						var p = ctx.map.project(coords);

						// point to draw
						var x = Math.round(p.x - s.x);
						var y = Math.round(p.y - s.y);
						return {
							x: x,
							y: y
						};
					},

					map_position_on_line_2_lat_lng: function(position_on_line){
						var lat_lng;
						var interpolator = d3.interpolateNumber(-1.793770, -3.212830);
						lat_lng = new L.LatLng(54.973934, interpolator(position_on_line));
						return lat_lng;
					},

					add_json_layers: function(){
						if(o.draw_hadrians_wall){
							jQuery.getJSON('static/data/hadrians-wall.json', function(d){
								L.geoJson(d, {
									style: function (feature) {
										return {
											"color": "#ff7800",
											"weight": 5,
											"opacity": 0.65
										};
									},
									onEachFeature: function (feature, layer) {
										layer.bindPopup(feature.properties.description);
									}
								}).addTo(internal.map);
							});
						}
							

						if(o.draw_balloons){
							jQuery.getJSON('static/data/balloons/output.json', function(d){
								L.geoJson(d, {
									style: function (feature) {
										return {
											"color": "#ff7800",
											"weight": 5,
											"opacity": 0.65
										};
									},
									onEachFeature: function (feature, layer) {
										layer.bindPopup(feature.properties.description);
									}
								}).addTo(internal.map);
							});
						}

					},



					animate: function(frame_time){
						var delta;
						delta = frame_time - internal.last_frame;
						internal.last_frame = frame_time;
						internal.stats.begin();
						internal.animation_frame_id = requestAnimationFrame( fn.animate );
						fn.draw(delta);
					},

					draw: function(){
						fn.update_particles();
						internal.canvasTiles.redraw();
						internal.stats.end();
						elements.n_particles.text(internal.particles.length);
					}
				};

				handlers = {
					keypress: function(e, d){
						console.log(e.which);
						if(e.which == 112){ // 'p'
							if(internal.animation_frame_id){
								cancelAnimationFrame(internal.animation_frame_id);
								internal.animation_frame_id = null;
							} else {
								internal.animation_frame_id = requestAnimationFrame(fn.animate);
							}
						} else if(e.which == 103){ // 'g'
							fn.generate_particles(10);
						}
					},
					resize: function(){
						internal.$e.css({
							'height': $(window).height() + 'px',
							'width': $(window).width() + 'px'
						});
					}
				};

				jQuery(window).bind('keypress', {}, handlers.keypress);
				jQuery(window).bind('resize', {}, handlers.resize);

				o.app.events.bind('app.featuresInitialized', {}, function(){
					fn.init();
					fn.animate();
				});
				
				console.log(internal);

			};

			window.page.features.push(function(app){
				app.runtime.viz = new Viz_Two({
					app: app,
					$e: $('#application'),
					width: $(window).width(),
					height: $(window).height()
				});
			});
			
			jQuery(document).bind('ready',function(){
				window.app = new NI.App({
					page: window.page
				});
			});
		</script>

	</body>
</html>
